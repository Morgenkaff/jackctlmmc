/***************************************************************************
 *   Copyright (C) 2009 by Alex Montgomery and Nedko Arnaudov   *
 *   check@Adaon   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <QMessageBox>
#include <QFile>
#include <QTextStream>
#include <QDir>
#include <QWhatsThis>
#include <QCloseEvent>

#include "mainWindow.h"
#include "validator.h"
#include "sequencerThread.h"

extern "C" {
#include "../../common.h"
}

MainWindow::MainWindow() : m_sequencerThread(0), m_settingsMutex(QMutex::Recursive)
{
   setupUi(this); // use the UI layout generated by qjackmmc.ui
   
   // make sure the fps and jitter edit boxes only take positive whole numbers
   QValidator* validator = new Validator(this);
   fpsEdit->setValidator(validator);
   jitterEdit->setValidator(validator);
   
   // make sure the device edit box only take positive hexadecimal values
   validator = new HexValidator(this);
   deviceEdit->setValidator(validator);

   // connect all UI editable elements
   connect(fpsEdit, SIGNAL(editingFinished()), this, SLOT(onValidateFps()));
   connect(jitterEdit, SIGNAL(editingFinished()), this, SLOT(onValidateJitter()));
   connect(deviceEdit, SIGNAL(editingFinished()), this, SLOT(onValidateDeviceID()));
   connect(rtBox, SIGNAL(clicked(bool)), this, SLOT(onRealtimeChanged(bool)));
   connect(verboseBox, SIGNAL(clicked(bool)), this, SLOT(onVerboseChanged(bool)));
   connect(whatsThisButton, SIGNAL(clicked()), this, SLOT(on_actionWhat_triggered()));

   // set the program's icon
   const QString iconPath(QString(ICON_DIR) + "/qjackmmc.png");
   if (QFile::exists(iconPath))
      setWindowIcon(QPixmap(iconPath));
}

bool MainWindow::init(int argc, char *argv[])
{
   bool succeeded = initSound(argc, argv); // setup Jack, ALSA, and Lash so the user can connect MIDI to the program

   if (succeeded)
   {
      setDefaultSettings();

      // load the default configuration file if it exists
      QFile loadFile(QDir::homePath() + QJACKMMC_CONFIG);
      if (loadFile.exists())
         loadConfig(loadFile);



      // start the MMC listener thread
      Q_ASSERT(!m_sequencerThread);
      m_sequencerThread = new SequencerThread(this, &m_settings, &m_settingsMutex);
      m_sequencerThread->listen(rtBox->isChecked());

      printMMCMessage("QJackMMC is actively listening for MMC messages. If you want to see information about them as they come in, make sure \"Verbose output\" is checked.");
   }

   return succeeded;
}

void MainWindow::on_actionQuit_triggered()
{
   close();
}

void MainWindow::on_actionAbout_triggered()
{
   QString message;
   message = QString(
      #include "../../VERSION"
            );
      
   QMessageBox* aboutBox = new QMessageBox(this);
   aboutBox->setText(message);
   aboutBox->exec();
}

void MainWindow::on_actionWhat_triggered()
{
   QWhatsThis::enterWhatsThisMode();
}

void MainWindow::on_loadButton_clicked()
{
   QFile loadFile(QDir::homePath() + QJACKMMC_CONFIG);
   if (loadFile.exists())
      loadConfig(loadFile);
   else
   {
      QMessageBox* fileError = new QMessageBox(this);
      fileError->setText(QDir::homePath() + QString(QJACKMMC_CONFIG) + " does not exist. You must save a default configuration before you can load one.");
      fileError->exec();
   }
}

void MainWindow::on_saveButton_clicked()
{
   QFile saveFile(QDir::homePath() + QJACKMMC_CONFIG);
   if (saveFile.open(QIODevice::WriteOnly | QIODevice::Text))
   {
      QTextStream out(&saveFile);
      
      // write out check boxes 
      int boolVal;
      boolVal = (verboseBox->isChecked() ? 1 : 0);
      out << boolVal << endl;
      boolVal = (rtBox->isChecked() ? 1 : 0);
      out << boolVal << endl;

      // note: this value is ignored but written for backwards compatibility.
      // It used to signify "listen on startup" but now QJackMMC is always listening.
      boolVal = false;
      out << boolVal << endl;
      
      // write out text boxes
      out << fpsEdit->text() << endl;
      out << jitterEdit->text() << endl;
      out << deviceEdit->text() << endl;
      
      if (saveFile.error() != QFile::NoError)
      {
         QMessageBox* jackError = new QMessageBox(this);
         jackError->setText("An error occurred while writing to " + QDir::homePath() + QString(QJACKMMC_CONFIG));
         jackError->exec();
      }
   }
   else
   {
      QMessageBox* fileError = new QMessageBox(this);
      fileError->setText(QDir::homePath() + QString(QJACKMMC_CONFIG) + " cannot be opened for writing. Make sure that you have permission to write to that directory and file.");
      fileError->exec();
   }
   
}

void MainWindow::onValidateFps()
{
   // validate setting, revert to prior value if not valid
   bool ok = true;
   int fps = fpsEdit->text().toInt(&ok);

   // we go to great lengths to make sure that the input boxes only accept positive integers, but check the fields just in case
   if (!ok || fps < 0)
   {
      QMessageBox* inputError = new QMessageBox(this);
      inputError->setText("the frames / sec parameter needs to be a positive integer.");
      inputError->exec();

      // revert value
      QMutexLocker settingsLock(&m_settingsMutex);
      fpsEdit->setText(QString::number(m_settings.frameRate));
   }
   else
   {
      QMutexLocker settingsLock(&m_settingsMutex);
      m_settings.frameRate = fps;
   }
}

void MainWindow::onValidateJitter()
{
   // validate setting, revert to prior value if not valid
   bool ok = true;
   int jitterTolerance = jitterEdit->text().toInt(&ok);
   if (!ok || jitterTolerance < 0)
   {
      QMessageBox* inputError = new QMessageBox(this);
      inputError->setText("the jitter tolerance needs to be a positive integer.");
      inputError->exec();

      // revert value
      QMutexLocker settingsLock(&m_settingsMutex);
      jitterEdit->setText(QString::number(m_settings.jitterTolerance));
   }
   else
   {
      QMutexLocker settingsLock(&m_settingsMutex);
      m_settings.jitterTolerance = jitterTolerance;
   }
}

void MainWindow::onValidateDeviceID()
{
   // validate setting, revert to prior value if not valid
   bool ok = true;
   int deviceID = deviceEdit->text().toInt(&ok, 16);
   if (!ok || deviceID > 255 || deviceID < 0)
   {
      QMessageBox* inputError = new QMessageBox(this);
      inputError->setText("the deviceID needs to be a hexadecimal number between 0 and ff.");
      inputError->exec();

      // revert value
      QMutexLocker settingsLock(&m_settingsMutex);
      deviceEdit->setText(QString::number(m_settings.deviceID));
   }
   else
   {
      QMutexLocker settingsLock(&m_settingsMutex);
      m_settings.deviceID = (uint8_t) deviceID;
   }
}


void MainWindow::onVerboseChanged(bool checked)
{
   QMutexLocker settingsLock(&m_settingsMutex);
   m_settings.verbose = checked;
}

void MainWindow::onRealtimeChanged(bool checked)
{
   if (m_sequencerThread)
      m_sequencerThread->die(); // die() calls deleteLater and ensures the thread is cleaned up once the listen loop ends

   m_sequencerThread = new SequencerThread(this, &m_settings, &m_settingsMutex);
   m_sequencerThread->listen(checked);

}

void MainWindow::onMessageReceived(QString message)
{
   messageArea->append(message);
}

bool MainWindow::initSound(int argc, char *argv[])
{
   bool succeeded = true, alsaPortCreated = false, jackPortCreated = false;
   int ret = init_alsa_sequencer("QJjackMMC");
   if (ret < 0)
   {
      QMessageBox* alsaError = new QMessageBox(this);
      alsaError->setText("Can't create alsa sequencer. You will not be able to connect MIDI devices to this program using ALSA. Jack Midi might still function.");
      alsaError->exec();
   }
   else
      alsaPortCreated = true;

   if (succeeded && init_jack("QJjackMMC") < 0)
   {
      QMessageBox* jackError = new QMessageBox(this);
      jackError->setText("couldn't connect to the JACK server. Would you like to start one with default parameters? (Answering \"No\" will close this program.)");
      jackError->addButton(QMessageBox::Yes);
      jackError->addButton(QMessageBox::No);
      if (jackError->exec() == QMessageBox::No)
         succeeded = false;
   }
#if LASH_SUPPORT
   init_lash(argc, argv);
#else
   Q_UNUSED(argc);
   Q_UNUSED(argv);
#endif // LASH_SUPPORT

#if JACK_MIDI_SUPPORT
   if (succeeded)
   {
      if (!init_jack_midi(&m_settings))
      {
         QMessageBox* activateError = new QMessageBox(this);
         activateError->setText("couldn't activate JACK midi, you will not be able to connect MIDI devices to this program using JACK midi.");
         activateError->exec();
      }
      else
         jackPortCreated = true;
   }
#endif // JACK_MIDI_SUPPORT

   if (succeeded && activate_jack() != 0)
   {
      QMessageBox* activateError = new QMessageBox(this);
      activateError->setText("couldn't activate JACK, Please check your JACK installation and rerun this program.");
      activateError->exec();
      succeeded = false;
   }

   if (jackPortCreated == false && alsaPortCreated == false)
   {
      QMessageBox* activateError = new QMessageBox(this);
      activateError->setText("Neither JACK midi nor ALSA midi could be initialized, bailing out.");
      activateError->exec();
      succeeded = false;
   }
   return succeeded;
}

void MainWindow::loadConfig(QFile& loadFile)
{
   if (loadFile.open(QIODevice::ReadOnly | QIODevice::Text))
   {
      QTextStream in(&loadFile);
      
      // read in check boxes
      int boolVal;
      in >> boolVal;
      verboseBox->setChecked(boolVal == 1);
      m_settings.verbose = boolVal == 1;
      in >> boolVal;
      rtBox->setChecked(boolVal == 1);

      // note: this value is ignored but read for backwards compatibility.
      // It used to signify "listen on startup" but now QJackMMC is always listening.
      in >> boolVal;
      
      // read in edit boxes
      QString value;
      in >> value; fpsEdit->setText(value);    onValidateFps();
      in >> value; jitterEdit->setText(value); onValidateJitter();
      in >> value; deviceEdit->setText(value); onValidateDeviceID();
      
      if (loadFile.error() != QFile::NoError)
      {
         QMessageBox* jackError = new QMessageBox(this);
         jackError->setText("An error occurred while reading " + QDir::homePath() + QString(QJACKMMC_CONFIG) +
                           ". The file is either nonexistent, corrupt, or from an older version of QJackMMC. Please set the QJackMMC parameters \
                           how you like them and click \"Save as Default settings\".");
         jackError->exec();
      }
   }
   else
   {
      QMessageBox* fileError = new QMessageBox(this);
      fileError->setText(QDir::homePath() + QString(QJACKMMC_CONFIG) + " cannot be opened for reading. It's either corrupt, or you don't have permission to read it.");
      fileError->exec();
   }
}

void MainWindow::setDefaultSettings()
{
   QMutexLocker settingsLocker(&m_settingsMutex);
   m_settings.deviceID = 0x7f;
   m_settings.frameRate = 30;
   m_settings.jitterTolerance = 50;
   m_settings.verbose = false;
}

void MainWindow::closeEvent(QCloseEvent* event)
{
   // separating the clean-up into the close event (instead of the destructor) prevents an XRun on shutdown
   if (m_sequencerThread)
   {
      m_sequencerThread->die(); // die() calls deleteLater and ensures the thread is cleaned up once the listen loop ends
      m_sequencerThread->wait();
   }

   cleanup_globals();
   event->accept();
}
